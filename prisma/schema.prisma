// ============================================================
// NotifyHub — Multi-Tenant SaaS Notification Platform
// ============================================================

generator client {
  provider = "prisma-client"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
}

// ─────────────────────────────────────────────────────────────
// Enums
// ─────────────────────────────────────────────────────────────

enum NotificationChannel {
  EMAIL
  SMS
  PUSH
}

enum NotificationStatus {
  PENDING
  QUEUED
  PROCESSING
  SENT
  DELIVERED
  FAILED
  CANCELLED
}

enum NotificationPriority {
  LOW
  NORMAL
  HIGH
  CRITICAL
}

enum TenantStatus {
  ACTIVE
  SUSPENDED
  INACTIVE
}

enum TenantPlan {
  FREE
  STARTER
  BUSINESS
  ENTERPRISE
}

enum ApiKeyStatus {
  ACTIVE
  REVOKED
  EXPIRED
}

enum ProviderStatus {
  ACTIVE
  DEGRADED
  DOWN
}

enum CircuitBreakerState {
  CLOSED
  OPEN
  HALF_OPEN
}

enum DeliveryEventType {
  QUEUED
  SENT
  DELIVERED
  BOUNCED
  OPENED
  CLICKED
  FAILED
  RETRIED
}

enum WebhookStatus {
  PENDING
  SUCCESS
  FAILED
}

enum DevicePlatform {
  IOS
  ANDROID
  WEB
}

// ─────────────────────────────────────────────────────────────
// Phase 3 — Multi-Tenant SaaS
// ─────────────────────────────────────────────────────────────

model User {
  id        String   @id @default(uuid())
  email     String   @unique
  name      String?
  password  String
  image     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

/// A business / organisation that uses the notification platform
model Tenant {
  id                String       @id @default(uuid())
  name              String
  slug              String       @unique
  status            TenantStatus @default(ACTIVE)
  plan              TenantPlan   @default(FREE)
  webhookUrl        String?      // callback URL for delivery events
  webhookSecret     String?      // HMAC secret for webhook signing
  settings          Json?        // arbitrary tenant-level config
  ownerId           String?

  // Rate-limit caps (Phase 2 + 3)
  rateLimitPerMinute Int         @default(60)
  rateLimitPerDay    Int         @default(100000)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  apiKeys            ApiKey[]
  recipients         Recipient[]
  notifications      Notification[]
  rateLimitLogs      RateLimitLog[]
  deliveryAggregates DeliveryAggregate[]
  webhookEvents      WebhookEvent[]
  templates          NotificationTemplate[]

  @@index([slug])
  @@index([status])
  @@index([ownerId])
}

/// API keys for tenant authentication (Phase 3)
model ApiKey {
  id         String       @id @default(uuid())
  tenantId   String
  name       String       // human-readable label
  keyHash    String       @unique // SHA-256 hash of the raw key
  prefix     String       // first 8 chars for identification (e.g., "nk_live_")
  status     ApiKeyStatus @default(ACTIVE)
  scopes     String[]     @default(["notifications:send"]) // permission scopes
  expiresAt  DateTime?
  lastUsedAt DateTime?
  createdAt  DateTime     @default(now())

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@index([tenantId])
  @@index([keyHash])
  @@index([prefix])
}

// ─────────────────────────────────────────────────────────────
// Phase 4 — User / Recipient Management
// ─────────────────────────────────────────────────────────────

model Recipient {
  id         String  @id @default(uuid())
  tenantId   String
  externalId String? // tenant's own user ID for mapping
  email      String?
  phone      String?
  name       String?
  timezone   String? @default("UTC")
  locale     String? @default("en")
  metadata   Json?   // arbitrary custom fields

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant        Tenant                   @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  deviceTokens  DeviceToken[]
  preferences   NotificationPreference[]
  notifications Notification[]

  @@unique([tenantId, externalId])
  @@unique([tenantId, email])
  @@unique([tenantId, phone])
  @@index([tenantId])
}

/// Push-notification device tokens (Phase 4)
model DeviceToken {
  id           String         @id @default(uuid())
  recipientId  String
  token        String
  platform     DevicePlatform
  isActive     Boolean        @default(true)
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  recipient Recipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([recipientId, token])
  @@index([recipientId])
}

/// Per-channel notification preferences & opt-in/out (Phase 4)
model NotificationPreference {
  id              String              @id @default(uuid())
  recipientId     String
  channel         NotificationChannel
  enabled         Boolean             @default(true) // opt-in / opt-out
  quietHoursStart String?             // "22:00" — no notifications after this
  quietHoursEnd   String?             // "08:00" — resume notifications

  recipient Recipient @relation(fields: [recipientId], references: [id], onDelete: Cascade)

  @@unique([recipientId, channel])
  @@index([recipientId])
}

// ─────────────────────────────────────────────────────────────
// Phase 1 — Core Notification Engine
// ─────────────────────────────────────────────────────────────

/// Reusable message templates (per tenant + channel)
model NotificationTemplate {
  id       String              @id @default(uuid())
  tenantId String
  name     String
  channel  NotificationChannel
  subject  String?             // email subject / push title
  body     String              // template body (supports variables)
  metadata Json?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant        Tenant         @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  notifications Notification[]

  @@unique([tenantId, name, channel])
  @@index([tenantId])
}

/// The core notification record (Phase 1)
model Notification {
  id             String               @id @default(uuid())
  tenantId       String
  recipientId    String?
  templateId     String?

  // Deduplication (Phase 1)
  idempotencyKey String?              @unique

  // Content
  channel        NotificationChannel
  priority       NotificationPriority @default(NORMAL)
  subject        String?              // email subject / push title
  body           String               // message content
  metadata       Json?                // extra data (deep-link, attachments…)

  // Delivery state machine: PENDING → QUEUED → PROCESSING → SENT → DELIVERED | FAILED
  status         NotificationStatus   @default(PENDING)

  // Scheduling
  scheduledAt    DateTime?            // null = send immediately

  // Timestamps
  queuedAt       DateTime?
  sentAt         DateTime?
  deliveredAt    DateTime?
  failedAt       DateTime?

  // Retry with exponential backoff (Phase 1)
  retryCount     Int                  @default(0)
  maxRetries     Int                  @default(3)
  nextRetryAt    DateTime?

  // Provider that handled delivery
  providerId     String?

  createdAt      DateTime             @default(now())
  updatedAt      DateTime             @updatedAt

  // Relations
  tenant    Tenant                @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  recipient Recipient?            @relation(fields: [recipientId], references: [id], onDelete: SetNull)
  template  NotificationTemplate? @relation(fields: [templateId], references: [id], onDelete: SetNull)
  provider  Provider?             @relation(fields: [providerId], references: [id], onDelete: SetNull)

  deliveryLogs   DeliveryLog[]
  deadLetterItem DeadLetterQueue?
  webhookEvents  WebhookEvent[]

  // Performance indexes (Phase 2 — partitioning-friendly)
  @@index([tenantId, status])
  @@index([tenantId, channel])
  @@index([tenantId, createdAt])
  @@index([status, nextRetryAt])          // worker retry polling
  @@index([recipientId])
  @@index([scheduledAt])
  @@index([idempotencyKey])
}

// ─────────────────────────────────────────────────────────────
// Phase 5 — Reporting & Analytics
// ─────────────────────────────────────────────────────────────

/// Granular delivery event log (Phase 1 + 5)
model DeliveryLog {
  id             String            @id @default(uuid())
  notificationId String
  eventType      DeliveryEventType
  provider       String?           // provider name at time of event
  statusCode     Int?              // HTTP / SMTP status code
  response       String?           // raw provider response (truncated)
  metadata       Json?
  timestamp      DateTime          @default(now())

  notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([notificationId])
  @@index([timestamp])
  @@index([eventType])
}

/// Pre-computed daily aggregates per tenant + channel (Phase 5)
model DeliveryAggregate {
  id             String              @id @default(uuid())
  tenantId       String
  channel        NotificationChannel
  date           DateTime            @db.Date

  totalSent      Int @default(0)
  totalDelivered Int @default(0)
  totalFailed    Int @default(0)
  totalBounced   Int @default(0)
  totalOpened    Int @default(0)
  totalClicked   Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, channel, date])
  @@index([tenantId, date])
}

// ─────────────────────────────────────────────────────────────
// Phase 6 — Reliability & Production Hardening
// ─────────────────────────────────────────────────────────────

/// Dead Letter Queue for permanently failed notifications (Phase 6)
model DeadLetterQueue {
  id             String  @id @default(uuid())
  notificationId String  @unique
  reason         String  // failure reason / error message
  payload        Json    // full original notification payload
  retryable      Boolean @default(false)
  processedAt    DateTime?
  createdAt      DateTime @default(now())

  notification Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)

  @@index([retryable, processedAt])
  @@index([createdAt])
}

/// External notification providers & circuit-breaker state (Phase 6)
model Provider {
  id                  String              @id @default(uuid())
  name                String              @unique // e.g. "sendgrid", "twilio", "firebase"
  channel             NotificationChannel
  isActive            Boolean             @default(true)
  isBackup            Boolean             @default(false) // fallback provider
  priority            Int                 @default(0)      // lower = higher priority
  config              Json?               // encrypted provider credentials & settings

  // Circuit Breaker (Phase 6)
  circuitState        CircuitBreakerState @default(CLOSED)
  failureCount        Int                 @default(0)
  failureThreshold    Int                 @default(5)
  successCount        Int                 @default(0)
  lastFailureAt       DateTime?
  lastSuccessAt       DateTime?
  circuitOpenedAt     DateTime?
  cooldownMs          Int                 @default(30000) // 30s before HALF_OPEN

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  notifications Notification[]

  @@index([channel, isActive, priority])
}

// ─────────────────────────────────────────────────────────────
// Phase 2 — Scalability helpers
// ─────────────────────────────────────────────────────────────

/// Sliding-window rate-limit counters per tenant + channel (Phase 2)
model RateLimitLog {
  id           String              @id @default(uuid())
  tenantId     String
  channel      NotificationChannel
  windowStart  DateTime
  requestCount Int                 @default(0)

  tenant Tenant @relation(fields: [tenantId], references: [id], onDelete: Cascade)

  @@unique([tenantId, channel, windowStart])
  @@index([tenantId, windowStart])
}

/// Webhook delivery attempts to tenant callback URLs (Phase 3 + 5)
model WebhookEvent {
  id             String        @id @default(uuid())
  tenantId       String
  notificationId String?
  eventType      String        // "notification.delivered", "notification.failed" …
  url            String
  payload        Json
  status         WebhookStatus @default(PENDING)
  attempts       Int           @default(0)
  maxAttempts    Int           @default(5)
  lastAttemptAt  DateTime?
  nextRetryAt    DateTime?
  responseCode   Int?
  responseBody   String?

  createdAt DateTime @default(now())

  tenant       Tenant        @relation(fields: [tenantId], references: [id], onDelete: Cascade)
  notification Notification? @relation(fields: [notificationId], references: [id], onDelete: SetNull)

  @@index([tenantId])
  @@index([status, nextRetryAt])
}

